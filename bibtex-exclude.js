#!/usr/bin/env node
/* jshint node: true, esversion: 6 */
'use strict';

const bibtex = require('bibtex-parse');
const { readdirSync, readFileSync, writeFileSync } = require('fs');

const parse = (path) => {
	try {
		let bib = readFileSync(path, 'utf8');
		return bibtex.parse(bib);
	} catch (e) {
		console.error(`error parsing ${path} [Line ${e.location.start.line}, ${e.location.start.column}]: ${e.message}`);
	}
};

const prop = (e, prop) => e.properties[prop] ? e.properties[prop].value : null;

const strval = (str = '') => (str || '').replace(/\W/g, '').toLowerCase();

const hash = e => ({
	authorTitle: strval((prop(e, 'author') || 'none').match(/([^\s]+)\s*(,|and |et |$)/)[1]) + ':' + // surname (comes before comma or 'and')
        strval(prop(e, 'title', '')).slice(0, 50),
    doi: prop(e, 'doi') ? strval(prop(e, 'doi')) : null,
    abstract: prop(e, 'abstract') ? strval(prop(e, 'abstract')).slice(0, 100) : null
});

const same = (e1, e2) => e1.similarityHash.doi && e1.similarityHash.doi === e2.similarityHash.doi ||
                         e1.similarityHash.abstract && e1.similarityHash.abstract === e2.similarityHash.abstract ||
                         e1.similarityHash.authorTitle === e2.similarityHash.authorTitle;

const serialize = entries => {
	return entries
		.sort((a, b) => a.hash < b.hash ? -1 : a.hash > b.hash ? 1 : 0)
		.map(entry => {
			let props = Object.keys(entry.properties)
				.map(k => {
					let v = entry.properties[k],
						val = String(v.value).replace(/\s+/g, ' '),
						braced = v.brace === 'curly' ? `{${val}}` : v.brace === 'quote' ? `"${val}"` : val;
					return `  ${k.padEnd(14)}= ${braced}`;
				});
			return `@${entry.type.toLowerCase()}{${entry.id},\n${props.join(',\n')}\n}`;
		})
		.join('\n');
};

const databases = readdirSync('databases').map(f => f.replace(/\.bib$/, ''));
const exclusionReasons = readdirSync('exclusions').map(f => f.replace(/\.bib$/, ''));
const entries = [];
const exclusions = [];

exclusionReasons.forEach(reason => {
	parse(`exclusions/${reason}.bib`).entries.forEach(e => {
		e.similarityHash = hash(e);
		e.reason = reason;
		exclusions.push(e);
	});
});

let resultCount = 0;

if (process.argv.includes('--new')) {
	readdirSync('.').forEach(f => {
		let match = f.match(/^results(\d*)\.bib$/);
		if (match) {
			let reason = `already in ${f}`;
			exclusionReasons.push(reason);
			let resultIndex = Number(match[1] || 0);
			if (resultIndex >= resultCount) {
				resultCount = resultIndex + 1;
			}
			parse(f).entries.forEach(e => {
				e.similarityHash = hash(e);
				e.reason = reason;
				exclusions.push(e);
			});
		}
	});
}


console.log('Loading databases...');
databases.forEach(database => {
	let dbentries = [];
	parse(`databases/${database}.bib`).entries.forEach(e => {
		e.similarityHash = hash(e);
		if (!dbentries.find(e_ => same(e, e_))) { dbentries.push(e); }
	});
	dbentries.forEach(e => {
		e.id = e.similarityHash.authorTitle.split(':')[0] + String(prop(e, 'year')).replace(/{|}/g, '');
		e.properties.database = { value: database, brace: 'curly' };
		e.duplicate = entries.find(e_ => same(e, e_));
		e.exclude = exclusions.find(e_ => same(e, e_));
		if (e.exclude) { e.exclude.used = true; }
		if (e.duplicate) {
			e.duplicate.properties.database.value += `, ${database}`;
			Object.keys(e.properties).forEach(k => {
				if (!e.duplicate.properties[k]) { e.duplicate.properties[k] = e.properties[k]; }
			});
		}
		entries.push(e);
	});
	console.log(`${database.padStart(30)}: ${dbentries.length}`);
});

let withoutDupes = entries.filter(e => !e.duplicate),
	eligible = withoutDupes.filter(e => !e.exclude);

console.log('Total'.padStart(30) + `: ${entries.length}`);
console.log('');
console.log('Removing duplicates...');
console.log('duplicates'.padStart(30) + `: (${entries.length - withoutDupes.length})`);
console.log('Total'.padStart(30) + `: ${withoutDupes.length}`);
console.log('');

console.log('Applying exclusions...');
exclusionReasons.forEach(reason => {
	let ineligible = withoutDupes.filter(e => e.exclude && e.exclude.reason === reason);
	console.log(reason.padStart(30) + `: (${ineligible.length})`);
});
console.log('TOTAL ELIGIBLE'.padStart(30) + `: ${eligible.length} (${withoutDupes.length} - ${withoutDupes.length - eligible.length})`);

let header = '% Results generated by bibtex-exclude\n';
let output = `results${resultCount || ''}.bib`;
writeFileSync(output, header + serialize(eligible), 'utf8');
console.log(`Results written to ${output}`);

/*const unusedExclusions = exclusions.filter(e => !e.used);
writeFileSync('unused-exclusions.bib', serialize(unusedExclusions), 'utf8');
exclusionReasons.forEach(name => {
	const usedExclusions = exclusions.filter(e => e.reason === name && e.used);
	writeFileSync(`exclusions/${name}.bib`, serialize(usedExclusions), 'utf8');
});
*/